Temel Türler & Null Güvenliği

1- `val` ile `var` arasındaki fark nedir?

    'val' ile 'var' keyword'leri değişken tanımlamak için kullanılır.
     'val' keyword'ü, read-only (sadece okunabilir) değişkenler tanımlamamıza
     olanak tanırken, 'var' keyword'ü ise mutable (değeri değişebilen) değişkenler
     tanımlamamıza olanak tanır. Aralarındaki temel fark budur.

=================================================================================

2- Bir `var` değişkeni `val` gibi davranmasını nasıl sağlayabiliriz `val` kelimesini kullanmadan?
 Bunu neden yapmak isteriz? Örnek bir senaryo verin.

    Bir 'var' değişkenin set'ini private yaparak 'val' gibi davranmasını sağlayabiliriz ama bunu sadece
     class'larda yapabiliriz çünkü fonksiyon içerisindeki değişkenlere sadece o fonksiyon içerisinden
     erişebiliriz. Bu yüzden de private set yapmanın bir mantığı kalmaz.

     Örn.
        var name = "Doğaç"
            private set  
     
    Peki oluşturduğumuz değişkenin set'ini neden private yapmak isteriz? Çünkü aynı class içerisinde 
     değiştirebiliriz fakat farklı class'larda sadece okuyabiliriz. Örnek senaryo olarak bir Person
     class'ımızın olduğunu düşünelim. Bu class'ın içerisinde de age isimli bir değişken var ve biz
     bu age değişkeninin sadece Person class'ında değiştirilebilmesini istiyoruz. Bu durumda private set
     kullanabiliriz. Peki neden değişkeni ilk başta private olarak tanımlamıyoruz? Çünkü farklı fonksiyonlarda
     bu age değişkenini okumak/kullanıcıya göstermek isteyebiliriz.

=================================================================================

3- "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın.
 `val` değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

    Immutable (Değişmez) ve read-only (salt okunur) kavramları birbirlerine çok benzerdir, fakat aralarında küçük
     bir fark vardır. Immutable'da, değişkenin değeri ilk tanımlamadan sonra hiçbir zaman, hiçbir şekilde
     değiştirilemez. Read-only'de ise, değişkenin değeri bazı durumlarda değiştirilebilir.
     'val' değişkenlerin immutable değil de read-only olmasının sebebi getter'ının olmasıdır. Değişkenin değerini
     getter kısmında verirsek, başka bir fonksiyondan da bu değişkeni değiştirebiliriz.

     Örn.
        fun main() {

            val math = Math()

            println(math.result)

            math.number2 = 50

            println(math.result)
        }

        class Math() {

            var number1 = 10
            var number2 = 20

            val result get() = number1 + number2
        }
    
    Bu kodda, main fonksiyonunda ilk başta sonucu bastırıyoruz ve val olarak tanımlanan 'result' değişkeninin
     değerinin 30 olduğunu görüyoruz. 'number2' değişkeninin değerini 50 ile değiştirip tekrardan sonucu
     bastırıyoruz ve bu sefer 'result' değişkeninin değerinin 60 olduğunu görüyoruz. Bu yüzden 'val' değişkenler
     immutable değil read-only'dir.

=================================================================================

4- "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

    Type inference (Tip çıkarımı) kavramı, bir değişken tanımlarken dilin, değişken tipini otomatik olarak tahmin
     etmesidir. Bu bizi gereksiz koddan kurtarır ve kodumuzu okunur kılar. Eğer değişkenler nullable olacaksa veya
     değişkenin değeri sonradan atanacaksa kesin olarak tip belirtmemiz gerekir.

=================================================================================

5- Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi?
 Arka planda neler oluyor?

    Kotlin'de tüm değişkenlerin/veri tiplerinin sınıf olarak bulunmasının sebebi, o değişkene ait fonksiyonları
     kullanabilmemiz içindir. Bu durum primitive type (ilkel tip) olmadıkları anlamına gelmez. Kotlin'de veri
     tipleri class olarak bulunuyor fakat proje derlenirken veya çalışırken bu class'lar primitive tiplere
     dönüştürülüyor. Eğer bir değişken, "primitive tipe dönüştürülebilen" bir veri yapısına atanıyorsa (Örn. Int)
     veya "primitive tipe dönüştürülebilen" bir veri yapısı içeren fonksiyon çağrılıyorsa bunlar, 
     compile time'da (derleme zamanı) primitive tip'e dönüştürülür. Eğer bir String'den, "primitive tipe
     dönüştürülebilen" bir veri yapısına (Örn. Int) 'as' keyword'ü ile cast işlemi yapılıyorsa veya String tipinden
     Int tipine bir dönüşüm yapılıyorsa (Örn. val number = "5".toInt()) bunlar runtime'da (çalışma zamanı) gerçekleşir.

=================================================================================

6- "Tip Güvenliği" (Type Safety) kavramını açıklayın.

    Type safety (tip güvenliği), program çalışırken alınabilecek tip hatalarına karşı koruma sağlayan bir özelliktir.
     Derleme sırasında her değişkenin ve ifadenin tipi kontrol edilir ve yalnızca uyumlu tipler arasındaki işlemlere
     izin verilir. Bu işlemin derleme sırasında yapılmasının sebebi ise program çalışırken, tip hatası yüzünden
     programın çökmemesini engellemek içindir. Type safety konusuna örnek olarak şu verilebilir; bir topla fonksiyonumuz
     var ve parametre olarak 'a: Int' ve 'b: Int' parametrelerini alıyor ve fonksiyon geriye 'Int' döndürüyor.
     Bu fonksiyonu, main fonksiyonunda çağırıp, değer olarak birine int birine double değer atarsak, program 
     derleme sırasında hata verecektir çünkü 'Double' ile 'Int'in toplamı sonuç olarak 'Double' döndürecektir.
     Topla fonksiyonu bizden 'Int' bir değer döndürmemizi beklediği için de hata verecektir. Bu hatayı kullanıcıya
     yansıtmamak için de derleme sırasında verir. Program hiç çalışmadan hata vermiş olur.

=================================================================================

7- Bir değişkeni nullable yapmak için ne yapmalıyız?

    Bir değişkeni nullable yapabilmek için ilk önce değişkenin tipini belirtmemiz gerekir. Değişkenin
     tipini belirttikten sonra yanına soru işareti (?) ekleyerek o değişkeni nullable yapabiliriz.

     Örn. val number: Int? = 5

    Bir değişkeni, değerini sonradan atamak için de nullable yapabiliriz. Bu işlemi sadece fonksiyonlarda
     yapabiliriz, class'larda yapamayız. Çeşitli sebeplerden dolayı bir değişkeni primitive tip olarak değil de
     class olarak tutmak isteyebiliriz. Böyle bir durumda da değişkenimizi nullable yapabiliriz. Değişkenimizi 'var'
     olarak tanımlayıp, ilk değerini null verebiliz ama daha sonrasında mutlaka bu değişkene bir değer atamamız gerekir
     yoksa hata alırız.

=================================================================================

8- "Null Güvenliği" (Null Safety) kavramını açıklayın.

    Null safety (null güvenliği), null değerlerle çalışmayı kolaylaştıran ve hataların önüne geçmemizi sağlayan bir özelliktir.
     Örneğin, nullable olarak tanımlanan bir değişkenle işlem yaparken Kotlin'e,"bu değişken null ise bu kodu çalıştırma,
     null değil ise çalıştır" kontrolünü yaparak hata alma riskini en aza indirmektir. Bu kontrolü, verinin geleceğinden eminsek
     "!!" operatörü ile, emin değilsek de "?." operatörü ile sağlayabiliriz. "!!" operatörü programa, "bu veri kesin gelecek"
     bilgisini verir ve program ona göre çalışır. "!!" operatörünü kullanırsak ama veri gelmezse programımız çöker. "!!" kullanmak
     yerine "?." kullanırsak da ilk başta bahsettiğim "bu değişken null ise bu kodu çalıştırma, null değil ise çalıştır" kontrolünü
     yaparak programı çalıştırır. Eğer veri yoksa o kod bloğu hiç çalışmaz, sadece veri varsa çalışır. Bu ikisinin dışında bir de
     elvis operatörü (?:) vardır. Elvis operatörü de "eğer veri varsa solumdaki işlemi yap, veri yoksa da sağımdaki işlemi yap"
     kontrolünü gerçekleştirir.

     Örn. println(name ?: "İsim boş") -> Eğer isim değişkeninde bir değer varsa o değeri yazdırır, değer yoksa da "İsim boş" yazdırır.

=================================================================================

9- Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

    Böyle bir durumda değişkenin tipi Nothing? olarak belirlenir ve daha sonra değiştirilemez. Nothing olarak belirlenen
     değişkenler de hiçbir işe yaramazlar çünkü Nothing boş bir class'tır. Bu değişkenin değerini sonradan değiştiremediğimiz
     için de bir işe yaramaz.

=================================================================================

10- İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

    Nullable değişkenler bellekte daha fazla yer kaplar çünkü arka tarafta bu veri tipleri class olarak tutulur.
     Nullable olmayan değişkenler ise daha az yer kaplar çünkü arka tarafta bu veri tipleri primitive tipe
     dönüştürülür.

=================================================================================

11- Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır?
 Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?

    Nullable bir değişken, 'null' dışında bir değere sahip olursa, null değer almış bir değişkene göre bellekte
     daha fazla yer kaplar. Bunun sebebi ise, 'null' değer alan bir değişken için bellekte sadece o değişkenin
     referansı tutulur. Bu da değer ataması olan bir değişkene göre bellekte daha az yer kaplar. Dolayısıyla
     null değer almış bir değişken bellekte yer kaplamaz diyemeyiz ama değeri atanmış bir değişkene göre daha az
     yer kaplar diyebiliriz.

=================================================================================

12- Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir?
 Hangisini ne zaman kullanmak daha anlamlıdır?

    Bu sorunun cevabını 8. soruda verdiğim için cevaplar aynı ama sonu farklı olacak.
     Nullable olarak tanımlanan bir değişkenle işlem yaparken Kotlin'e,"bu değişken null ise bu kodu çalıştırma,
     null değil ise çalıştır" kontrolünü yaparak hata alma riskini en aza indirmektir. Bu kontrolü, verinin geleceğinden eminsek
     "!!" operatörü ile, emin değilsek de "?." operatörü ile sağlayabiliriz. "!!" operatörü programa, "bu veri kesin gelecek"
     bilgisini verir ve program ona göre çalışır. "!!" operatörünü kullanırsak ama veri gelmezse programımız çöker. "!!" kullanmak
     yerine "?." kullanırsak da ilk başta bahsettiğim "bu değişken null ise bu kodu çalıştırma, null değil ise çalıştır" kontrolünü
     yaparak programı çalıştırır. Eğer veri yoksa o kod bloğu hiç çalışmaz, sadece veri varsa çalışır. Bu ikisinin dışında bir de
     elvis operatörü (?:) vardır. Elvis operatörü de "eğer veri varsa solumdaki işlemi yap, veri yoksa da sağımdaki işlemi yap"
     kontrolünü gerçekleştirir.

     Örn. println(name ?: "İsim boş") -> Eğer isim değişkeninde bir değer varsa o değeri yazdırır, değer yoksa da "İsim boş" yazdırır.

     "!!" operatörünü, "programımın/uygulamamın çökmesi, yanlış değer göstermektense daha iyi" dediğimiz zamanlarda kullanırız.
     "?." veya elvis operatörünü de (?:), "Yanlış değer göstermek çok sıkıntı olmaz, yeterki programım/uygulamam çökmesin" dediğimiz
     zamanlarda kullanırız.

=================================================================================
=================================================================================

Sayılar

1- Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?

    'Number' class'ını miras alan 6 tane child class vardır. Bunlar; Byte, Short, Int, Long, Float ve Double'dır.
     Bu child class'ların değer aralıkları, bellekte tuttukları yer açısından önemlidir. Değer aralıkları arttıkça
     bellek kullanımı da artacaktır. Bu yüzden ihtiyacımız olan doğru veri tipini kullanmalıyız.

=================================================================================

2- Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?

    Bir değişkene tip belirtimi yapılmadan bir değer atanırsa, değerin tipine ve aralığına göre otomatik
     olarak tip ataması yapılır. Otomatik değer atamalarında 'Byte' ve 'Short' kullanılmaz. Int'in değer
     aralığında olan tüm sayılar için 'Int', daha yüksek sayılar için 'Long', kesirli sayılar içinse
     'Double' tipi atanır.

=================================================================================

3- Float değişken oluştururken `F` ve `f` harfleri varken, Long değişken oluştururken neden küçük `l` harfi yoktur?

    Çünkü küçük 'l' harfi bazı fontlarda '1' rakamına benzediği için, karıştırma durumuna karşın böyle bir önlem
     alınmıştır.

=================================================================================

4- Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.

    Single precision sayılar, bellekte 32 bit olarak saklanır. Bu sayılar, 2^32 - 1 (yaklaşık 4.3 milyar)
     kadar kesirli sayı değerini temsil edebilir. Programlama dillerinde genelde 'Float' keyword'ü ile
     kullanılır. Double precision'a göre daha az hassastır ve daha az yerler kaplar. Double precision ise,
     bellekte 64 bit olarak saklanır. Bu sayılar, 2^64 - 1 (yaklaşık 18.4 trilyon) kadar kesirli sayı değerini
     temsil edebilir. Programlama dillerinde genelde 'Double' keyword'ü ile kullanılır. Single precision'a göre
     daha hasasstır ve daha fazla yer kaplar.

=================================================================================

5- Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır?
 Bu ayıraçların kullanımında nelere dikkat etmek gerekir?

    'Double' ve 'Float' değişkenleriyle çalışırken ondalık ayracı olarak nokta (.) kullanılır.
     Bu ayraç kullanılırken karıştırılıp nokta yerine virgül (,) kullanılabilir. Buna dikkat
     etmek gerekir. İnternetten veya başka bir yerden veri çekerken de ondalık ayracı virgül
     olarak gelebilir. Bunları dikkatli bir şekilde noktaya çevirmemiz gerekir.

=================================================================================

6- Double ve Float değişkenler ondalık kısımda kaç basamağa kadar işlem yaparlar?
 Bu sınırın üzerinde gelen ondalık bilgileri için nasıl davranırlar? 
 Hangi durumlar için Float ve hangi durumlar için Double kullanılmalıdır?

    Float değişkenler 32 bitlik olup, 6-7 basamağa kadar doğru sonuçlar verir.
     Double değişkenler ise 64 bitlik olup 15-16 basamağa kadar doğru sonuçlar verir.
     Bu sınırın üzerine çıkıldığında ise ya değerler yuvarlanır ya da kesilir. Örneğin
     bir işlemin sonucu olarak Double "0.3333333333333333" sonucunu verirken Float,
     "0.33333334" verir. Sonucun hassasiyeti çok önemli değilse Float, sonucun
     hassasiyeti çok önemliyse de Double kullanılır.

=================================================================================